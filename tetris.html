<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mưa Từ — Chế độ Giai đoạn</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#101216; --panel:#1e2127; --panel2:#3c4148; --text:#ececec; --accent:#50b4ff; --danger:#ff8c8c;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{font-family:"Noto Sans",system-ui,"Segoe UI",Roboto,Helvetica,Arial,"Apple SD Gothic Neo",sans-serif;background:var(--bg);color:var(--text);}
    .wrap{max-width:980px;margin:0 auto;padding:16px;}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px}
    header h1{font-size:18px;margin:0;color:#fff}
    .hud{display:flex;gap:12px;align-items:center;justify-content:space-between;background:var(--panel);padding:8px 12px;border-radius:10px;margin-bottom:8px}
    .hud .stat{opacity:.95}
    canvas{display:block;width:100%;height:520px;background:linear-gradient(#0f1319,#0c0f14);border:1px solid #0006;border-radius:14px}
    .inputbar{margin-top:8px;background:var(--panel);padding:12px;border-radius:12px}
    .inputrow{display:flex;gap:8px;align-items:center}
    .inputrow input{flex:1;border:1px solid #0003;background:var(--panel2);color:var(--text);padding:10px 12px;border-radius:10px;font-size:16px;outline:none}
    .inputrow button{border:none;background:var(--accent);color:#001422;padding:10px 14px;border-radius:10px;font-weight:700;cursor:pointer}
    .footer{opacity:.7;margin-top:10px;font-size:13px}
    .badge{padding:4px 8px;border-radius:8px;background:#00000033}
    .gameover{position:absolute;inset:0;display:none;align-items:center;justify-content:center}
    .card{background:#000a;padding:24px 28px;border-radius:16px;border:1px solid #ffffff22;backdrop-filter: blur(4px); text-align: center;}
    .card h2{margin:0 0 12px}
    .card .row{margin:6px 0}
    .show{display:flex}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Mưa Từ — Chế độ Giai đoạn</h1>
    </header>

    <div class="hud">
      <div class="stat">Cấp: <b id="level">1/10</b></div>
      <div class="stat">Tiến độ: <b id="progress">0/4</b></div>
      <div class="stat">Đã phá: <b id="score">0</b> từ</div>
      <div class="stat">WPM: <b id="wpm">0.0</b></div>
    </div>

    <div style="position:relative">
      <canvas id="game" width="980" height="520"></canvas>
      <div id="gameover" class="gameover">
        <div class="card">
          <h2 id="goTitle">THUA RỒI</h2>
          <div class="row">Giai đoạn cuối cùng: <b id="goLevel">1</b></div>
          <div class="row">Từ đúng: <b id="goWords">0</b></div>
          <div class="row">Ký tự đúng: <b id="goChars">0</b></div>
          <div class="row">WPM (chuẩn 5 ký tự): <b id="goWpm">0.0</b></div>
          <div class="row" style="margin-top:10px"><button id="goRestart">Chơi lại</button></div>
        </div>
      </div>
    </div>

    <div class="inputbar">
      <div class="inputrow">
        <input id="typebox" placeholder="Gõ từ ở đây rồi nhấn Enter…" />
        <button id="fireBtn">Phá</button>
      </div>
      <div class="footer">Âm thanh: "tetris" (nhạc ngắn khi lên cấp), "explosion" (khi phá từ), "game over" khi thua. Trình duyệt cần thao tác đầu để bật âm thanh.</div>
    </div>
  </div>

<script>
(function(){
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const typebox = document.getElementById('typebox');
  const levelEl = document.getElementById('level');
  const progressEl = document.getElementById('progress');
  const scoreEl = document.getElementById('score');
  const wpmEl = document.getElementById('wpm');
  const go = document.getElementById('gameover');
  const goTitle = document.getElementById('goTitle');
  const goLevel = document.getElementById('goLevel');
  const goWords = document.getElementById('goWords');
  const goChars = document.getElementById('goChars');
  const goWpm = document.getElementById('goWpm');
  const goRestart = document.getElementById('goRestart');
  const fireBtn = document.getElementById('fireBtn');

  const W = cvs.width, H = cvs.height;
  const inputTop = H - 84;
  const fontFamily = 'Noto Sans, system-ui, Arial, sans-serif';

  // ----- Web Audio (SFX) -----
  let audio, unlocked = false;
  function initAudio(){
    if (unlocked) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return;
    audio = new AC();
    unlocked = true;
  }
  function env(startTime, dur, startGain=0.12, endGain=0.0001){
    const g = audio.createGain();
    g.gain.setValueAtTime(startGain, startTime);
    g.gain.exponentialRampToValueAtTime(endGain, startTime + dur);
    return g;
  }
  function osc(type, freq){
    const o = audio.createOscillator();
    o.type = type; o.frequency.value = freq; return o;
  }
  function playTetrisJingle(){
    if (!unlocked) return;
    const now = audio.currentTime;
    const seq = [523.25, 659.25, 783.99, 1046.5];
    seq.forEach((f, i)=>{
      const t = now + i*0.08;
      const o = osc('square', f);
      const g = env(t, 0.12, 0.12, 0.0001);
      o.connect(g).connect(audio.destination);
      o.start(t); o.stop(t+0.12);
    });
  }
  function playExplosion(){
    if (!unlocked) return;
    const now = audio.currentTime;
    const bufferSize = audio.sampleRate * 0.2;
    const buffer = audio.createBuffer(1, bufferSize, audio.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++){ data[i] = (Math.random()*2-1) * (1 - i/bufferSize); }
    const src = audio.createBufferSource(); src.buffer = buffer;
    const g = env(now, 0.25, 0.2, 0.0001);
    const filter = audio.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(1800, now);
    src.connect(filter).connect(g).connect(audio.destination);
    src.start(now);
  }
  function playGameOver(){
    if (!unlocked) return;
    const now = audio.currentTime;
    const freqs = [523.25, 392.00, 329.63, 261.63];
    freqs.forEach((f, i)=>{
      const t = now + i*0.2;
      const o = osc('square', f);
      const g = env(t, 0.18, 0.12, 0.0001);
      o.connect(g).connect(audio.destination);
      o.start(t); o.stop(t+0.18);
    });
  }

  // ----- Game state -----
  let wordsPool = [
    'phương đẹp', 'phương xinh', 'phương hiền', 'phương ngoan', 'phương giỏi',
    'phương ngọt', 'phương dễ', 'phương ngầu', 'phương quý', 'phương sang',
    'phương tươi', 'phương sáng', 'phương vui', 'phương chăm', 'phương khỏe',
    'phương nhanh', 'phương khéo', 'phương tin', 'phương ấm', 'phương dịu',
    'phương hiếu', 'phương tinh', 'phương trong', 'phương an', 'phương bền',
    'phương sâu', 'phương khôn', 'phương mềm', 'phương êm', 'phương hay',
    'phương hiếm', 'phương thơm', 'phương giòn', 'phương mới', 'phương quen',
    'phương ngây', 'phương tĩnh', 'phương bình', 'phương khích', 'phương nhiệt',
    'phương trẻ', 'phương mát', 'phương dễ thương', 'phương quý phái', 'phương vui vẻ'
];
  let active = [];
  let particles = [];
  let usedIdx = 0;
  let scoreWords = 0;
  let correctChars = 0;
  let startTime = 0;
  let gameOver = false;
  let reqId = null;
  
  let level = 1;
  const WORDS_PER_LEVEL = 4;
  const MAX_LEVEL = 10;
  let clearedThisLevel = 0;

  function baseSpeed(level){ return 15 + (level-1)*8; }
  function shuffle(a){ for (let i=a.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
  function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }
  function randFloat(a,b){ return a + Math.random()*(b-a); }
  function measure(text, font){ ctx.save(); ctx.font = font; const width = ctx.measureText(text).width; ctx.restore(); return {width}; }

  function pickWord(){
    if (usedIdx >= wordsPool.length){ shuffle(wordsPool); usedIdx = 0; }
    return wordsPool[usedIdx++];
  }

  function rangesOverlap(aStart, aEnd, bStart, bEnd){
    return Math.max(aStart, bStart) < Math.min(aEnd, bEnd);
  }

  function spawn(){
    const text = pickWord();
    const metrics = measure(text, '20px ' + fontFamily);
    const margin = 24;
    const y = -24 - randInt(0, 80);
    const spd = baseSpeed(level) * randFloat(0.95, 1.1);

    const pad = 40;
    const maxAttempts = 24;
    let attempt = 0, x = randInt(margin, Math.max(margin, W - metrics.width - margin));

    while (attempt < maxAttempts){
      let overlap = false;
      for (const w of active){
        const wWidth = w.w || measure(w.text, '20px ' + fontFamily).width;
        if (rangesOverlap(x - pad, x + metrics.width + pad, w.x - pad, w.x + wWidth + pad)){
          overlap = true; break;
        }
      }
      if (!overlap) break;
      x = randInt(margin, Math.max(margin, W - metrics.width - margin));
      attempt++;
    }

    active.push({text, x, y, spd, w: metrics.width});
  }

  function draw(){
    const now = performance.now();
    const elapsed = (now - startTime)/1000;
    const minutes = Math.max(1/60, elapsed/60);
    wpmEl.textContent = ((correctChars/5)/minutes).toFixed(1);
    
    ctx.clearRect(0,0,W,H);

    ctx.textBaseline = 'top';
    ctx.font = '20px ' + fontFamily;
    for (const w of active){
      const near = (inputTop - (w.y + 22)) < 60;
      ctx.fillStyle = near ? '#ff8c8c' : '#ececec';
      ctx.fillText(w.text, w.x, w.y);
    }

    ctx.fillStyle = '#1e2127';
    ctx.fillRect(0, inputTop, W, 84);
    ctx.fillStyle = '#3c4148';
    ctx.fillRect(12, inputTop+12, W-24, 84-24);

    particles = particles.filter(p=>p.life>0);
    for (const p of particles){
      p.vy += 600 * p.dt;
      p.x += p.vx * p.dt; p.y += p.vy * p.dt; p.life -= p.dt;
      ctx.fillStyle = 'rgb(255,200,100)';
      ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
    }

    if (!gameOver){
      const dt = 1/60;
      let hit = false;
      for (const w of active){
        w.y += w.spd * dt;
        if ((w.y + 22) >= inputTop){ hit = true; }
      }
      if (hit){ finalize('hit'); }
      reqId = requestAnimationFrame(draw);
    }
  }

  function finalize(kind){
    if (gameOver) return;
    gameOver = true;
    const nowElapsed = (performance.now() - startTime)/1000;
    const minutes = Math.max(1/60, nowElapsed/60);
    const finalWPM = (correctChars/5)/minutes;

    if (kind === 'win') {
        goTitle.textContent = 'CHIẾN THẮNG!';
    } else { // 'hit'
        goTitle.textContent = 'THUA RỒI';
    }
    goLevel.textContent = level;
    goWords.textContent = scoreWords;
    goChars.textContent = correctChars;
    goWpm.textContent = finalWPM.toFixed(1);
    go.classList.add('show');
    cancelAnimationFrame(reqId);

    if (kind !== 'win') playGameOver();
    stopBGM();
  }
  
  // --- EDITED SECTION ---
  // This function now spawns words with a delay between them.
  function setupLevel(newLvl) {
    level = newLvl;
    clearedThisLevel = 0;
    active = [];
    levelEl.textContent = `${level}/${MAX_LEVEL}`;
    progressEl.textContent = `0/${WORDS_PER_LEVEL}`;

    let spawnedCount = 0;
    const spawnIntervalId = setInterval(() => {
        if (gameOver) {
            clearInterval(spawnIntervalId);
            return;
        }
        if (spawnedCount < WORDS_PER_LEVEL) {
            spawn();
            spawnedCount++;
        } else {
            clearInterval(spawnIntervalId);
        }
    }, 600); // Spawn a word every 600ms

    if (level > 1) {
        playTetrisJingle();
    }
  }

  function reset(){
    active = []; particles = []; usedIdx = 0; scoreWords = 0; correctChars = 0; gameOver=false;
    level = 1; clearedThisLevel = 0;
    
    levelEl.textContent = '1/10';
    progressEl.textContent = '0/4';
    scoreEl.textContent = '0';
    wpmEl.textContent = '0.0';

    ctx.clearRect(0,0,W,H);
    go.classList.remove('show');
  }

  function start(){
    reset();
    
    if (!unlocked) initAudio();
    if (!bgmUnlocked) bgmInit();
    
    shuffle(wordsPool);
    startTime = performance.now();
    setupLevel(1);
    requestAnimationFrame(draw);
    typebox.focus();
    startBGM();
  }

  typebox.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter' && !gameOver){
      const typed = typebox.value.trim();
      if (!typed) return;
      const idx = active.findIndex(w => w.text === typed);
      if (idx !== -1){
        const w = active[idx];
        active.splice(idx,1);
        
        scoreWords += 1;
        correctChars += typed.length;
        clearedThisLevel++;

        scoreEl.textContent = scoreWords;
        progressEl.textContent = `${clearedThisLevel}/${WORDS_PER_LEVEL}`;
        
        playExplosion();
        for (let i=0;i<24;i++){
          particles.push({x:w.x+40,y:w.y+12,vx:randFloat(-150,150),vy:randFloat(-220,-40),life:randFloat(.35,.6),dt:1/60,r:randFloat(2,4)});
        }

        if (clearedThisLevel >= WORDS_PER_LEVEL) {
            if (level >= MAX_LEVEL) {
                finalize('win');
            } else {
                setTimeout(() => setupLevel(level + 1), 600);
            }
        }
      }
      typebox.value = '';
    }
  });

  fireBtn.addEventListener('click', ()=>{
    typebox.focus();
    const e = new KeyboardEvent('keydown', {key:'Enter'}); typebox.dispatchEvent(e);
  });
  goRestart.addEventListener('click', start);

  window.addEventListener('load', start);

  // ======== BGM ========
  let bgmCtx = null, bgmGain = null, bgmTimer = null;
  let bgmUnlocked = false;
  const BGM_BPM = 148;
  const SIXTEENTH = 60 / BGM_BPM / 4;

  function bgmInit(){
    if (bgmUnlocked) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return;
    bgmCtx = new AC({ latencyHint: 'interactive' });
    bgmGain = bgmCtx.createGain();
    bgmGain.gain.value = 0.18;
    bgmGain.connect(bgmCtx.destination);
    bgmUnlocked = true;
  }

  function pulse(out, freq, t, dur, duty=0.25){
    if (!freq) return;
    const osc = bgmCtx.createOscillator();
    const real = new Float32Array(2), imag = new Float32Array(2);
    real[1] = Math.cos(Math.PI * duty); imag[1] = Math.sin(Math.PI * duty);
    const wave = bgmCtx.createPeriodicWave(real, imag, { disableNormalization: true });
    osc.setPeriodicWave(wave);
    osc.frequency.setValueAtTime(freq, t);

    const env = bgmCtx.createGain();
    env.gain.setValueAtTime(0.0001, t);
    env.gain.exponentialRampToValueAtTime(1.0, t + 0.01);
    env.gain.exponentialRampToValueAtTime(0.6, t + Math.max(0.04, dur*0.35));
    env.gain.setTargetAtTime(0.0001, t + dur - 0.03, 0.02);

    osc.connect(env).connect(out);
    osc.start(t); osc.stop(t + dur + 0.05);
  }

  const MEL = [
    [659.25,2],[493.88,1],[523.25,1],[587.33,2],[523.25,2],[493.88,2],[440.00,4],
    [0,2],[523.25,2],[659.25,4],[587.33,2],[523.25,2],[493.88,4],
  ];
  const BASS = [
    [220.00,2],[329.63,2],[440.00,2],[329.63,2],
    [196.00,2],[293.66,2],[392.00,2],[293.66,2],
  ];

  function startBGM(){
    if (!bgmCtx) return;
    
    const now = bgmCtx.currentTime;
    bgmGain.gain.cancelScheduledValues(now);
    bgmGain.gain.setValueAtTime(bgmGain.gain.value, now);
    bgmGain.gain.linearRampToValueAtTime(0.18, now + 0.1);

    let tLead = bgmCtx.currentTime + 0.05;
    let tBass = tLead;

    function schedulePhrase(){
      for (const [f, l] of MEL){
        const d = l * SIXTEENTH * 0.98;
        pulse(bgmGain, f, tLead, d, 0.125);
        tLead += l * SIXTEENTH;
      }
      for (const [f, l] of BASS){
        const d = l * SIXTEENTH * 0.98;
        pulse(bgmGain, f, tBass, d, 0.5);
        tBass += l * SIXTEENTH;
      }
    }

    schedulePhrase();
    if (bgmTimer) clearInterval(bgmTimer);
    bgmTimer = setInterval(()=>{
      if (tLead - bgmCtx.currentTime < 0.4){
        schedulePhrase();
      }
    }, 50);
  }

  function stopBGM(){
    if (!bgmCtx) return;
    if (bgmTimer) { clearInterval(bgmTimer); bgmTimer = null; }
    const now = bgmCtx.currentTime;
    try{
      bgmGain.gain.cancelScheduledValues(now);
      bgmGain.gain.setTargetAtTime(0.0001, now, 0.06);
    }catch(e){}
  }

  ['pointerdown','keydown'].forEach(evt=>{
    window.addEventListener(evt, ()=>{
        if (audio && audio.state === 'suspended') {
            audio.resume();
        }
        if (bgmCtx && bgmCtx.state === 'suspended') {
            bgmCtx.resume();
        }
    }, {once:true, passive:true});
  });

})();
</script>
</body>
</html>

